Model :
The class #ImageManager was meant to contain functionalities that edit images for the purpose of setting them in the needed form for the layer to process them. Some of these functionalities are "loadInput()", "resize()", "preProcess()". For the purpose of a cleaner code, these functionalities have been included in the class #Image, as it makes more sense to contain the modifying functions in the object class itself.
The class #DataSaver is meant to work as a data base, it consists of one map whose keys are images'  unique identifications #id, and whose values are results, represented as well as a an object. DataSaver allows the program to store input images and their results, retrieve them, delete them, or change their values. It also offers the possibility of saving the results of one classification in a text file. The aggregate function stores all classnames and percentages in a new map named #global, converts the map into a vector to sort it, then chooses the 4 biggest values and returns them as a #Result object.
The class #Result wasn't included in the design, and was added for the purpose of making the storage clearer and more flexible. It is meant to represent the results of a classification of a single input image as follows. Each instance of the object Result contains a map, that stores classnames represented as strings, and links them to their values stored as floats. Functionalities included are saving a classname and its percentage into the map. To control the number of classnames needed, we added the int i who counts the number of elements which are currently saved. This class offers the possibility to write results as plain text to display it on the GUI as such, classname1 : percentage1, classname2 : percentage2 etc ... 
Classes #InputImage and #ResultImage were not needed as results are only to display as text for the moment, as for input images, they are simply represented as instances of the class #Image.
Classes #Topology and #TopologyDisplayer were not needed, since layers are modelized as single objects, so is the neural network. To display the topology of the neural network, an image whose path has been set from the beginning is displayed, in order to give an idea about the structure of the implemented neural network.
Class #ClassificationAssistant has been renamed into Assistant. It serves the purpose of providing all data given by the user through the GUI to the system. The weight file is loaded directly into the network through a configuration file, so it doesn't belong to the assistant anymore. The boolean function is classified has been removed since it hasn't been needed. The file of the classnames file is set in the assistant, which will then be able to load them into a list of strings. Input images are stored into a list as well, with the possibility of deleting them by selection, or clearing the whole list.
Classes #Mode, and the three different modes that inherit from it were set to be represented as a public enumeration type inside the class #Scheduler as such Mode {standard, high_performance, low_power, energy_efficient} , since they contain no functionality, but only describe states.
Class #Scheduler has been set for the service of enabling and selecting the platforms corresponding to the selected mode. Following this logic, an enumeration type has been defined under the name Platform {cpu, gpu, fpga}. The class also consists of two other vectors of booleans. The first, named platforms, represents the platforms that the user has chosen to enable. The second, named use_platforms, defines which platforms are to run the code on, but only after the user chooses the operating mode. The choice of the use of platforms follows a comparison of the three platforms on three different levels, supposing that the code is meant to run parallel and contains mainly vector operations. 
 *		Power Consumption : cpu>gpu>fpga
 * 		Performance : fpga>gpu>cpu
 * 		Efficiency : fpga>cpu>gpu
 Next to accessing information about the mode and currently enabled/used platforms, #Scheduler also contains a vector of workers, whose size has to be defined while creating an instance of the class. Each worker can be assigned to execute a task on a selected platform, which he would only do if, this platform is allowed to use after the choosing process. A group of methods has been also made available for a possibly future parallel implementation of the classification.
 As for the progress bar, it seems that its implementation is more complicated than expected, which delayed its implementation to a future time due to more urgent functionalities not being implem yet.
